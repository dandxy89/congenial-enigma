use nom::sequence::tuple;

use crate::nom::{
    decoder::{objective::objectives_section, problem_name::parse_comments, sense::parse_problem_sense},
    model::{Objective, Sense},
};

pub fn parse_lp_file(input: &str) -> Result<(Option<&str>, Sense, Vec<Objective>), nom::Err<nom::error::Error<&str>>> {
    // Parse the full structure with tuple combinator
    let (remaining, (comments, sense, objectives)) = tuple((
        // LP Problem Name
        parse_comments,
        // LP Sense
        parse_problem_sense,
        // Objective Section
        objectives_section,
    ))(input)?;

    // Make sure we consumed all input (or handle remaining if needed)
    if !remaining.trim().is_empty() {
        println!("Warning: Unparsed content remains: {remaining}");
    }

    Ok((comments, sense, objectives))
}

#[cfg(test)]
mod test {
    use crate::nom::{decoder::lp_problem::parse_lp_file, model::Sense};

    #[test]
    fn test_sections_so_far() {
        let input = "\\ This file has been generated by Author
\\ ENCODING=ISO-8859-1
\\Problem name: diet
Minimize
 obj1: -0.5 x - 2y - 8z
 obj2: y + x + z
 obj3: 10z - 2.5x
       + y";
        let parsed_result = parse_lp_file(input);
        assert!(parsed_result.is_ok());

        let (comments, sense, objectives) = parsed_result.unwrap();
        assert!(comments.is_some());
        assert!(matches!(sense, Sense::Minimize));
        insta::assert_debug_snapshot!(objectives);
    }
}
