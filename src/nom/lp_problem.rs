use std::{
    borrow::Cow,
    collections::{hash_map::Entry, HashMap},
};

use nom::{combinator::opt, sequence::tuple};

use crate::nom::{
    decoder::{
        constraint::{parse_constraint_header, parse_constraints},
        objective::parse_objectives,
        problem_name::parse_problem_name,
        sense::parse_sense,
        variable::{parse_binary_section, parse_bounds_section, parse_generals_section, parse_integer_section, parse_semi_section},
    },
    model::{Constraint, Objective, Sense, Variable},
    take_until_parser, ALL_VAR_BOUND_HEADERS, BINARY_HEADERS, BOUND_HEADERS, CONSTRAINT_HEADERS, GENERAL_HEADERS, SEMI_HEADERS,
    SOS_HEADERS,
};

#[cfg_attr(feature = "diff", derive(diff::Diff), diff(attr(#[derive(Debug, PartialEq)])))]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, Default, PartialEq)]
pub struct LPProblem<'a> {
    pub name: Option<&'a str>,
    pub sense: Sense,
    pub objectives: HashMap<&'a str, Objective<'a>>,
    pub constraints: HashMap<Cow<'a, str>, Constraint<'a>>,
    pub variables: HashMap<&'a str, Variable<'a>>,
}

impl LPProblem<'_> {
    #[inline]
    /// Returns the name of the LP Problem
    pub fn name(&self) -> Option<&str> {
        self.name
    }

    #[inline]
    /// Returns `true` if the `Self` a Minimize LP Problem
    pub fn is_minimization(&self) -> bool {
        self.sense.is_minimization()
    }

    #[inline]
    /// Returns the number of constraints contained within the Problem
    pub fn constraint_count(&self) -> usize {
        self.constraints.len()
    }

    #[inline]
    /// Returns the number of objectives contained within the Problem
    pub fn objective_count(&self) -> usize {
        self.objectives.len()
    }

    #[inline]
    /// Returns the number of variables contained within the Problem
    pub fn variable_count(&self) -> usize {
        self.variables.len()
    }
}

impl<'a> TryFrom<&'a str> for LPProblem<'a> {
    type Error = nom::Err<nom::error::Error<&'a str>>;

    fn try_from(input: &'a str) -> Result<Self, Self::Error> {
        let (input, (name, sense, obj_section, _cons_header)) =
            tuple((parse_problem_name, parse_sense, take_until_parser(&CONSTRAINT_HEADERS), parse_constraint_header))(input)?;
        let (_, (objs, mut variables)) = parse_objectives(obj_section)?;

        let (input, constraint_str) = take_until_parser(&BOUND_HEADERS)(input)?;
        let (_, (constraints, constraint_vars)) = parse_constraints(constraint_str)?;
        variables.extend(constraint_vars);

        let (input, bound_str) = take_until_parser(&ALL_VAR_BOUND_HEADERS)(input)?;
        let (_, bounds) = parse_bounds_section(bound_str)?;

        for (bound_name, var_type) in bounds {
            match variables.entry(bound_name) {
                Entry::Occupied(mut occupied_entry) => {
                    occupied_entry.get_mut().set_vt(var_type);
                }
                Entry::Vacant(vacant_entry) => {
                    vacant_entry.insert(Variable { name: bound_name, var_type });
                }
            }
        }

        let (input, integer_str) = opt(take_until_parser(&GENERAL_HEADERS))(input)?;
        if let Some(integer_str) = integer_str {
            let (_, _integer_var) = parse_integer_section(integer_str)?;
        }

        let (input, generals_str) = opt(take_until_parser(&BINARY_HEADERS))(input)?;
        if let Some(generals_str) = generals_str {
            let (_, _general_var) = parse_generals_section(generals_str)?;
        }

        let (_input, binary_str) = opt(take_until_parser(&SEMI_HEADERS))(input)?;
        if let Some(binary_str) = binary_str {
            let (_, _binary_vars) = parse_binary_section(binary_str)?;
        }

        let (_input, semi_str) = opt(take_until_parser(&SOS_HEADERS))(input)?;
        if let Some(semi_str) = semi_str {
            let (_, _semi_continuous_vars) = parse_semi_section(semi_str)?;
        }

        Ok(LPProblem { name, sense, objectives: objs, constraints, variables })
    }
}

#[cfg(test)]
mod test {
    const SMALL_INPUT: &str = "\\ This file has been generated by Author
\\ ENCODING=ISO-8859-1
\\Problem name: diet
Minimize
 obj1: -0.5 x - 2y - 8z
 obj2: y + x + z
 obj3: 10z - 2.5x
       + y
subject to:
c1:  3 x1 + x2 + 2 x3 = 30
c2:  2 x1 + x2 + 3 x3 + x4 >= 15
c3:  2 x2 + 3 x4 <= 25
bounds
x1 free
x2 >= 1
100 <= x2dfsdf <= -1
Generals
Route_A_1
Route_A_2
Route_A_3
End";

    #[cfg(feature = "serde")]
    #[test]
    fn test_minified_example() {
        let problem = crate::nom::lp_problem::LPProblem::try_from(SMALL_INPUT).expect("test case not to fail");

        assert_eq!(problem.objectives.len(), 3);
        assert_eq!(problem.constraints.len(), 3);

        insta::assert_yaml_snapshot!(&problem, {
            ".objectives" => insta::sorted_redaction(),
            ".constraints" => insta::sorted_redaction(),
            ".variables" => insta::sorted_redaction()
        });
    }

    #[cfg(feature = "serde")]
    #[test]
    fn test_serialization_lifecycle() {
        let problem = crate::nom::lp_problem::LPProblem::try_from(SMALL_INPUT).expect("test case not to fail");
        // Serialised
        let serialized_problem = serde_json::to_string(&problem).expect("test case not to fail");
        // Deserialise
        let _: crate::nom::lp_problem::LPProblem<'_> = serde_json::from_str(&serialized_problem).expect("test case not to fail");
    }
}
